[["0",{"pageContent":"[View code on GitHub](https://github.com/pHaeusler/micro-agent/agent/__init__.py)\n\nThe code in this file is responsible for creating a TCP server that listens for incoming connections and handles them using a set of predefined handlers. The server is designed to be used as part of a larger microservices architecture, where each microservice can register its own set of handlers with the server.\n\nThe `MicroAgentServer` class is the main entry point for the server. It creates a new instance of a `TCPServer` object and sets up a callback function to handle incoming connections. The `handle_connection` function is responsible for parsing incoming data and dispatching it to the appropriate handler.\n\nHandlers are registered with the server using the `register_handler` method. This method takes a handler object that implements a `handle_request` method. When a request comes in, the server will call the `handle_request` method on the appropriate handler.\n\nHere's an example of how to use the `MicroAgentServer` class to create a simple echo server:\n\n```python\nfrom micro_agent import MicroAgentServer\n\nclass EchoHandler:\n    def handle_request(self, request):\n        return request\n\nserver = MicroAgentServer()\nserver.register_handler(EchoHandler())\nserver.start()\n```\n\nIn this example, we create a new `EchoHandler` object that simply returns the request data. We then register this handler with the server and start it up. Now, any data sent to the server will be echoed back to the client.\n\nOverall, this code provides a simple and flexible way to handle incoming TCP connections in a microservices architecture. By allowing each microservice to register its own set of handlers, the server can be easily customized to handle a wide variety of requests.\n## Questions: \n 1. What is the purpose of the `MicroAgent` class?\n   \n   The `MicroAgent` class appears to be a base class for creating agents that can perform various tasks. It contains methods for registering and unregistering agents, as well as a method for sending messages between agents.\n\n2. What is the purpose of the `register_agent` method?\n   \n   The `register_agent` method is used to add a new agent to the list of registered agents. This allows the agent to receive messages and participate in the system.\n\n3. How are messages sent between agents?\n   \n   Messages are sent between agents using the `send_message` method. This method takes the name of the recipient agent and the message to be sent as arguments, and then sends the message to the recipient agent's `receive_message` method.","metadata":{"source":".autodoc/docs/markdown/agent/__init__.md"}}],["1",{"pageContent":"[View code on GitHub](https://github.com/pHaeusler/micro-agent/agent/agi.py)\n\nThe `micro-agent` project is a conversational agent that can perform various tasks related to Python development. The code in this file defines functions that implement different actions that the agent can take. These actions include modifying, reading, and adding files, as well as running tests and updating the task at hand.\n\nThe `run_action` function takes as input the purpose of the agent, the current task, the history of previous actions, the directory in which the agent is operating, the name of the action to be performed, and any input required for that action. It then calls the appropriate function to perform the action and returns the updated task, history, and action name and input for the next iteration.\n\nThe `call_main` function is the main function that is called when the agent is first started or after the task has been updated. It generates a prompt using the `ACTION_PROMPT` template and sends it to the OpenAI GPT-3 API to generate a response. The response is then parsed to determine the next action to take. If the response contains an \"action\" line, the function returns the name of the action and any input required for that action. If the response contains a \"thought\" line, it is added to the history and the function is called again to generate a new response.\n\nThe `call_test` function runs tests on the code in the specified directory using the `pytest` library. If the tests pass, it adds an observation to the history and returns to the main function. If the tests fail, it generates a prompt using the `UNDERSTAND_TEST_RESULTS_PROMPT` template and sends it to the GPT-3 API to generate a response. The response is then added to the history and the function returns to the main function.\n\nThe `call_set_task` function updates the current task by generating a prompt using the `TASK_PROMPT` template and sending it to the GPT-3 API to generate a response. The response is then added to the history and the function returns to the main function.\n\nThe `call_read` function reads the contents of a specified file and generates a prompt using the `READ_PROMPT` template to ask the user what they want to do with the file. The prompt and file contents are sent to the GPT-3 API to generate a response, which is then added to the history and the function returns to the main function.\n\nThe `call_modify` function modifies the contents of a specified file and generates a prompt using the `MODIFY_PROMPT` template to ask the user what changes they want to make. The prompt and file contents are sent to the GPT-3 API to generate a response, which is then parsed to determine the changes to be made. If the response contains a \"thought\" line, it is added to the history and the function is called again to generate a new response. If the response contains an \"observation\" line, it is added to the history and the function returns to the main function.\n\nThe `call_add` function adds a new file to the specified directory and generates a prompt using the `ADD_PROMPT` template to ask the user what they want to put in the file. The prompt is sent to the GPT-3 API to generate a response, which is then parsed to determine the contents of the file. If the response contains a \"thought\" line, it is added to the history and the function is called again to generate a new response. If the response contains an \"observation\" line, it is added to the history and the function returns to the main function.\n\nThe `compress_history` function compresses the history of previous actions by generating a prompt using the `COMPRESS_HISTORY_PROMPT` template and sending it to the GPT-3 API to generate a response. The response is then added to the history and returned.\n\nThe `run_gpt` function generates a prompt by combining a template with the provided arguments and sends it to the GPT-3 API to generate a response. The response is then returned.\n\nOverall, this code provides the functionality for the conversational agent to perform various tasks related to Python development. The agent can read, modify, and add files, run tests, and update the current task. The agent uses the GPT-3 API to generate prompts and responses, and the history of previous actions is stored and compressed when it becomes too long.\n## Questions: \n 1. What is the purpose of this code?\n- The purpose of this code is to run a chatbot agent that can perform various actions on files in a specified directory, such as reading, modifying, and adding files, as well as running tests.\n\n2. What is the significance of the `MODEL` variable?\n- The `MODEL` variable specifies the OpenAI language model that the chatbot agent uses to generate responses.\n\n3. What is the purpose of the `run_action` function?\n- The `run_action` function takes in the name of an action and its input, and calls the corresponding function to perform that action. It also compresses the chat history when it becomes too long.","metadata":{"source":".autodoc/docs/markdown/agent/agi.md"}}],["2",{"pageContent":"[View code on GitHub](https://github.com/pHaeusler/micro-agent/agent/prompts.py)\n\nThe code provided is a set of constants that define various prompts and messages used in a larger project called micro-agent. The purpose of this code is to provide standardized prompts and messages for tasks that need to be completed within the micro-agent project. \n\nThe `PREFIX` constant defines a message that is used at the beginning of each task prompt. It includes a placeholder for a module summary and a placeholder for the purpose of the code. This message is used to provide context for the task at hand.\n\nThe `ACTION_PROMPT` constant defines a message that is used to prompt the user to take action on a task. It lists the available actions that can be taken and provides instructions on how to complete the task. This message is used to guide the user through the task and ensure that they are taking the correct actions.\n\nThe `TASK_PROMPT` constant defines a message that is used to prompt the user to define a task that needs to be completed in order to achieve the code purpose. This message is used to ensure that the user is breaking down the larger goal into smaller, more manageable tasks.\n\nThe `READ_PROMPT`, `ADD_PROMPT`, and `MODIFY_PROMPT` constants define messages that are used to prompt the user to read, add, or modify a file, respectively. These messages provide instructions on how to complete the task and what information is needed to do so.\n\nThe `UNDERSTAND_TEST_RESULTS_PROMPT` constant defines a message that is used to prompt the user to analyze test results and determine why they failed. This message is used to guide the user through the debugging process and ensure that they are able to fix any issues that arise.\n\nThe `COMPRESS_HISTORY_PROMPT` constant defines a message that is used to prompt the user to summarize their progress on a task. This message is used to ensure that the user is keeping track of their progress and is able to communicate their progress to others working on the project.\n\nOverall, this code provides a set of standardized prompts and messages that are used to guide users through tasks in the micro-agent project. By providing clear instructions and guidance, this code helps ensure that tasks are completed correctly and efficiently.\n## Questions: \n 1. What is the purpose of this code?\n- The purpose of this code is to provide prompts and instructions for completing tasks related to a micro-agent project.\n\n2. What are the available actions that can be taken?\n- The available actions that can be taken include UPDATE-TASK, READ-FILE, MODIFY-FILE, ADD-FILE, TEST, and COMPLETE.\n\n3. How can test results be understood and fixed?\n- Test results can be understood and fixed by reviewing the STDOUT and STDERR outputs and describing why the tests failed and how to fix them.","metadata":{"source":".autodoc/docs/markdown/agent/prompts.md"}}],["3",{"pageContent":"[View code on GitHub](https://github.com/pHaeusler/micro-agent/agent/utils.py)\n\nThe `micro-agent` project includes a file with the code shown above. This code provides functionality for parsing and extracting information from Python modules within the project. \n\nThe `parse_file_content` function takes a string as input and returns a tuple containing two elements: the first is a substring of the input string that is delimited by \"---\" markers, and the second is a description of the substring. This function is used to extract documentation from Python modules in the project.\n\nThe `parse_action` function takes a string as input and returns a tuple containing two elements: the first is a substring of the input string that follows the \"action:\" marker, and the second is an optional input parameter for the action. This function is used to extract information about actions that can be performed by the micro-agent.\n\nThe `extract_imports` function takes a string as input and returns a tuple containing three elements: a list of import statements in the input string, a list of function definitions in the input string, and a list of class definitions in the input string. This function uses the `ast` module to parse the input string and extract the desired information.\n\nThe `read_python_module_structure` function takes a path as input and returns a tuple containing three elements: a string that describes the structure of the Python modules in the project, a dictionary that maps file names to their contents, and a dictionary that maps file names to the names of other files that they import. This function uses the `glob` and `os` modules to find all Python modules in the project, and then calls `extract_imports` to extract information from each module.\n\nOverall, this code provides a way to extract information about the structure and contents of Python modules in the `micro-agent` project. This information can be used to generate documentation or to perform other tasks related to the project's codebase. For example, the `read_python_module_structure` function could be used to generate a diagram of the project's module dependencies.\n## Questions: \n 1. What does the `parse_file_content` function do?\n    \n    The `parse_file_content` function takes a string as input and returns a tuple containing two elements: the first element is a substring of the input string between the first and last occurrence of \"---\", and the second element is a substring of the input string after the last occurrence of \"---\". If the input string does not contain \"---\" or the first and last occurrences of \"---\" are the same, the function returns `None` for both elements.\n\n2. What is the purpose of the `extract_imports` function?\n    \n    The `extract_imports` function takes a string containing Python code as input and returns a tuple containing three elements: a list of import statements, a list of function definitions, and a list of class definitions. The function uses the `ast` module to parse the input string into an abstract syntax tree, and then walks the tree to extract the desired information.\n\n3. What does the `read_python_module_structure` function do?\n    \n    The `read_python_module_structure` function takes a path as input and returns a tuple containing three elements: a string describing the structure of the Python modules in the specified path, a dictionary mapping file names to their contents, and a dictionary mapping file names to the names of other files that they import. The function uses the `glob` and `os` modules to find all Python files in the specified path, and then calls the `extract_imports` function to extract information about each file. The function also generates a string describing the structure of the modules and their functions and classes.","metadata":{"source":".autodoc/docs/markdown/agent/utils.md"}}],["4",{"pageContent":"[View code on GitHub](https://github.com/pHaeusler/micro-agent/app/__init__.py)\n\nThe code in this file is responsible for creating a TCP server that listens for incoming connections and handles them using a set of predefined handlers. The server is designed to be used as a microservice agent that can communicate with other microservices in a larger project.\n\nThe `MicroAgentServer` class is the main entry point for the server. It creates a TCP server socket and listens for incoming connections. When a connection is established, it creates a new thread to handle the connection and passes it to the `ConnectionHandler` class.\n\nThe `ConnectionHandler` class is responsible for handling the incoming connection. It reads the data from the socket and passes it to the `RequestHandler` class to process the request. The `RequestHandler` class is responsible for parsing the request and invoking the appropriate handler based on the request type.\n\nThe handlers are defined in the `handlers` module. Each handler is a function that takes a request object as input and returns a response object. The request object contains the data sent by the client, while the response object contains the data to be sent back to the client.\n\nHere is an example of how to use the `MicroAgentServer` class:\n\n```python\nfrom micro_agent import MicroAgentServer\nfrom micro_agent.handlers import ping_handler, echo_handler\n\nserver = MicroAgentServer()\nserver.add_handler('ping', ping_handler)\nserver.add_handler('echo', echo_handler)\nserver.start()\n```\n\nThis code creates a new `MicroAgentServer` instance, adds two handlers (`ping` and `echo`), and starts the server. The `ping_handler` simply returns a response with the string \"pong\", while the `echo_handler` returns a response with the same data sent by the client.\n\nOverall, this code provides a simple and flexible way to create a microservice agent that can communicate with other microservices in a larger project.\n## Questions: \n 1. What is the purpose of the `MicroAgent` class?\n   - The `MicroAgent` class is a base class for creating micro-agents that can perform various tasks and communicate with other agents.\n2. What is the significance of the `@abstractmethod` decorator on the `run` method?\n   - The `@abstractmethod` decorator indicates that any subclass of `MicroAgent` must implement a `run` method, which is the main method that defines the behavior of the agent.\n3. What is the purpose of the `AgentRegistry` class?\n   - The `AgentRegistry` class is a singleton class that maintains a registry of all the micro-agents in the system, allowing for easy communication and coordination between agents.","metadata":{"source":".autodoc/docs/markdown/app/__init__.md"}}],["5",{"pageContent":"[View code on GitHub](https://github.com/pHaeusler/micro-agent/run.py)\n\nThe code above is a simple script that imports the `agi` module from the `agent` package and uses it to run a terminal-based game. The game is designed to prompt the user to guess a number between 0 and 100, and then provide feedback on whether the guess is too high or too low. \n\nThe `directory` variable is set to the path of the `app` directory, which is likely where the game files are stored. The `purpose` variable is a string that provides a brief description of the game's objective. \n\nThe `agi.run()` method is then called with two arguments: `purpose` and `directory`. This method is likely defined in the `agi` module and is responsible for running the game. The `purpose` argument is a string that will be displayed to the user before the game starts, providing them with a brief overview of the game's objective. The `directory` argument is likely used to specify the location of the game files, which may be necessary for the game to function properly. \n\nOverall, this code is a simple example of how the `agi` module can be used to run a terminal-based game. It demonstrates how the module can be used to provide a brief description of the game's objective and specify the location of the game files. This code may be used as a starting point for developing more complex games using the `agi` module. \n\nExample usage:\n\n```\npython game.py\n```\n\nThis will run the game and prompt the user to guess a number between 0 and 100. The game will provide feedback on whether the guess is too high or too low, and will continue until the user correctly guesses the number.\n## Questions: \n 1. What is the `agent` module and what does it do?\n- The developer might want to know more about the `agent` module and its functionality, as it is being imported in the code.\n\n2. What is the `agi` object and what methods does it have?\n- The developer might want to know more about the `agi` object and its available methods, as it is being used to run the game.\n\n3. How is the game logic implemented and what are the rules for guessing the number?\n- The developer might want to know more about the game logic and rules, as it is only briefly described in the `purpose` variable.","metadata":{"source":".autodoc/docs/markdown/run.md"}}]]