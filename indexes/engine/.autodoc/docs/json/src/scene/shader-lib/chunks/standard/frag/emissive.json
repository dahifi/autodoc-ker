{
  "fileName": "emissive.js",
  "filePath": "src/scene/shader-lib/chunks/standard/frag/emissive.js",
  "url": "https://github.com/playcanvas/engine/src/scene/shader-lib/chunks/standard/frag/emissive.js",
  "summary": "This code is a shader code written in GLSL (OpenGL Shading Language) that is used to calculate the emission of a material. The purpose of this code is to determine how much light a material emits, which is important for creating realistic lighting in a 3D scene. \n\nThe code starts by defining two uniforms: `material_emissive` and `material_emissiveIntensity`. These uniforms are used to specify the color and intensity of the material's emission. The `#ifdef` statements are used to conditionally compile the code based on whether certain features are enabled or not. \n\nThe `getEmission()` function is the main function that calculates the emission of the material. It starts by setting the initial emission value to `vec3(1.0)`, which means that the material emits white light. \n\nThe `#ifdef MAPFLOAT` block multiplies the emission value by the `material_emissiveIntensity` uniform, which is a float value that specifies the intensity of the emission. \n\nThe `#ifdef MAPCOLOR` block multiplies the emission value by the `material_emissive` uniform, which is a vec3 value that specifies the color of the emission. \n\nThe `#ifdef MAPTEXTURE` block multiplies the emission value by a texture value that is sampled using the `texture2DBias()` function. This function takes three arguments: the sampler, the UV coordinates, and the texture bias. The texture bias is used to adjust the texture sampling to avoid texture seams. The `$DECODE` macro is used to decode the texture value into a vec4 value, which is then accessed using the `$CH` macro to get the desired channel (red, green, or blue). \n\nThe `#ifdef MAPVERTEX` block multiplies the emission value by the vertex color of the mesh. This is done using the `vVertexColor` variable, which is a varying variable that is interpolated across the mesh. The `saturate()` function is used to clamp the vertex color to the range [0, 1], and the `gammaCorrectInput()` function is used to apply gamma correction to the color. \n\nOverall, this code is an important part of the PlayCanvas engine's rendering pipeline, as it determines how much light a material emits. It can be used to create a wide range of effects, from glowing objects to emissive surfaces. Here is an example of how this code might be used in a larger project:\n\n```glsl\n// vertex shader\nattribute vec3 aPosition;\nattribute vec2 aTexCoord;\nattribute vec3 aVertexColor;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvarying vec2 vTexCoord;\nvarying vec3 vVertexColor;\n\nvoid main() {\n    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);\n    vTexCoord = aTexCoord;\n    vVertexColor = aVertexColor;\n}\n\n// fragment shader\nuniform sampler2D uTexture;\n\n#ifdef MAPCOLOR\nuniform vec3 material_emissive;\n#endif\n\n#ifdef MAPFLOAT\nuniform float material_emissiveIntensity;\n#endif\n\nvarying vec2 vTexCoord;\nvarying vec3 vVertexColor;\n\nvoid getEmission() {\n    // code from previous example\n}\n\nvoid main() {\n    vec4 texColor = texture2D(uTexture, vTexCoord);\n    vec3 diffuse = texColor.rgb;\n    vec3 emission = vec3(0.0);\n\n    getEmission();\n\n    gl_FragColor = vec4(diffuse + emission, texColor.a);\n}\n```\n\nIn this example, the vertex shader passes the vertex color to the fragment shader using a varying variable. The fragment shader samples a texture and calculates the diffuse color using the texture color. The `getEmission()` function is called to calculate the emission color, which is added to the diffuse color to get the final color of the pixel.",
  "questions": "1. What is the purpose of this code?\n   This code defines a function called `getEmission()` that calculates the emissive color of a material based on various inputs such as color, texture, and vertex color.\n\n2. What are the `MAPFLOAT`, `MAPCOLOR`, `MAPTEXTURE`, and `MAPVERTEX` preprocessor directives used for?\n   These directives are used to conditionally compile different parts of the code based on whether certain material properties are present. For example, `MAPFLOAT` is used to compile code that handles a float value for emissive intensity.\n\n3. What is the meaning of the `/* glsl */` comment at the beginning of the code?\n   This comment indicates that the code is written in GLSL (OpenGL Shading Language), which is a high-level language used to write shaders for graphics processing units (GPUs). The comment is used by tools that parse GLSL code to identify the language and apply appropriate syntax highlighting and other features."
}