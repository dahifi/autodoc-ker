{
  "fileName": "loader.js",
  "filePath": "src/framework/handlers/loader.js",
  "url": "https://github.com/playcanvas/engine/src/framework/handlers/loader.js",
  "summary": "# ResourceLoader Class\n\nThe `ResourceLoader` class is responsible for loading resource data, potentially from remote sources, and caching the resource on load to prevent multiple requests. It also adds `ResourceHandlers` to handle different types of resources.\n\n## Constructor\n\nThe constructor takes an `app` parameter, which is an instance of `AppBase`. It initializes the `_handlers`, `_requests`, `_cache`, and `_app` properties.\n\n```javascript\nconstructor(app) {\n    this._handlers = {};\n    this._requests = {};\n    this._cache = {};\n    this._app = app;\n}\n```\n\n## Methods\n\n### addHandler(type, handler)\n\nThis method adds a `ResourceHandler` for a resource type. The handler should support at least `load()` and `open()`. Handlers can optionally support `patch(asset, assets)` to handle dependencies on other assets.\n\n```javascript\naddHandler(type, handler) {\n    this._handlers[type] = handler;\n    handler._loader = this;\n}\n```\n\n### removeHandler(type)\n\nThis method removes a `ResourceHandler` for a resource type.\n\n```javascript\nremoveHandler(type) {\n    delete this._handlers[type];\n}\n```\n\n### getHandler(type)\n\nThis method gets a `ResourceHandler` for a resource type.\n\n```javascript\ngetHandler(type) {\n    return this._handlers[type];\n}\n```\n\n### load(url, type, callback, asset)\n\nThis method makes a request for a resource from a remote URL. It parses the returned data using the handler for the specified type. When loaded and parsed, it uses the callback to return an instance of the resource.\n\n```javascript\nload(url, type, callback, asset) {\n    const handler = this._handlers[type];\n    if (!handler) {\n        const err = `No resource handler for asset type: '${type}' when loading [${url}]`;\n        Debug.errorOnce(err);\n        callback(err);\n        return;\n    }\n\n    // handle requests with null file\n    if (!url) {\n        this._loadNull(handler, callback, asset);\n        return;\n    }\n\n    const key = url + type;\n\n    if (this._cache[key] !== undefined) {\n        // in cache\n        callback(null, this._cache[key]);\n    } else if (this._requests[key]) {\n        // existing request\n        this._requests[key].push(callback);\n    } else {\n        // new request\n        this._requests[key] = [callback];\n\n        const self = this;\n\n        const handleLoad = function (err, urlObj) {\n            if (err) {\n                self._onFailure(key, err);\n                return;\n            }\n\n            handler.load(urlObj, function (err, data, extra) {\n                // make sure key exists because loader\n                // might have been destroyed by now\n                if (!self._requests[key]) {\n                    return;\n                }\n\n                if (err) {\n                    self._onFailure(key, err);\n                    return;\n                }\n\n                try {\n                    self._onSuccess(key, handler.open(urlObj.original, data, asset), extra);\n                } catch (e) {\n                    self._onFailure(key, e);\n                }\n            }, asset);\n        };\n\n        const normalizedUrl = url.split('?')[0];\n        if (this._app.enableBundles && this._app.bundles.hasUrl(normalizedUrl)) {\n            if (!this._app.bundles.canLoadUrl(normalizedUrl)) {\n                handleLoad(`Bundle for ${url} not loaded yet`);\n                return;\n            }\n\n            this._app.bundles.loadUrl(normalizedUrl, function (err, fileUrlFromBundle) {\n                handleLoad(err, {\n                    load: fileUrlFromBundle,\n                    original: normalizedUrl\n                });\n            });\n        } else {\n            handleLoad(null, {\n                load: url,\n                original: asset && asset.file.filename || url\n            });\n        }\n    }\n}\n```\n\n### open(type, data)\n\nThis method converts raw resource data into a resource instance. For example, it takes 3D model format JSON and returns a `Model`.\n\n```javascript\nopen(type, data) {\n    const handler = this._handlers[type];\n    if (!handler) {\n        console.warn('No resource handler found for: ' + type);\n        return data;\n    }\n\n    return handler.open(null, data);\n}\n```\n\n### patch(asset, assets)\n\nThis method performs any operations on a resource that require a dependency on its asset data or any other asset data.\n\n```javascript\npatch(asset, assets) {\n    const handler = this._handlers[asset.type];\n    if (!handler)  {\n        console.warn('No resource handler found for: ' + asset.type);\n        return;\n    }\n\n    if (handler.patch) {\n        handler.patch(asset, assets);\n    }\n}\n```\n\n### clearCache(url, type)\n\nThis method removes a resource from the cache.\n\n```javascript\nclearCache(url, type) {\n    delete this._cache[url + type];\n}\n```\n\n### getFromCache(url, type)\n\nThis method checks the cache for a resource from a URL. If present, it returns the cached value.\n\n```javascript\ngetFromCache(url, type) {\n    if (this._cache[url + type]) {\n        return this._cache[url + type];\n    }\n    return undefined;\n}\n```\n\n### enableRetry(maxRetries)\n\nThis method enables retrying of failed requests when loading assets. The `maxRetries` parameter is the maximum number of times to retry loading an asset. It defaults to 5.\n\n```javascript\nenableRetry(maxRetries = 5) {\n    maxRetries = Math.max(0, maxRetries) || 0;\n\n    for (const key in this._handlers) {\n        this._handlers[key].maxRetries = maxRetries;\n    }\n}\n```\n\n### disableRetry()\n\nThis method disables retrying of failed requests when loading assets.\n\n```javascript\ndisableRetry() {\n    for (const key in this._handlers) {\n        this._handlers[key].maxRetries = 0;\n    }\n}\n```\n\n### destroy()\n\nThis method destroys the resource loader.\n\n```javascript\ndestroy() {\n    this._handlers = {};\n    this._requests = {};\n    this._cache = {};\n}\n```\n\n## Callbacks\n\n### ResourceLoaderCallback\n\nThis callback is used by `ResourceLoader.load()` when a resource is loaded (or an error occurs). It takes two parameters:\n\n- `err`: The error message in the case where the load fails.\n- `resource`: The resource that has been successfully loaded.\n\n```javascript\n/**\n * Callback used by {@link ResourceLoader#load} when a resource is loaded (or an error occurs).\n *\n * @callback ResourceLoaderCallback\n * @param {string|null} err - The error message in the case where the load fails.\n * @param {*} [resource] - The resource that has been successfully loaded.\n */\n```",
  "questions": "1. What is the purpose of the `ResourceLoader` class?\n- The `ResourceLoader` class is used to load resource data, potentially from remote sources, and caches the resource on load to prevent multiple requests. It also allows for the addition and removal of `ResourceHandlers` to handle different types of resources.\n\n2. What is the `load` method used for?\n- The `load` method is used to make a request for a resource from a remote URL, parse the returned data using the handler for the specified type, and return an instance of the resource using the provided callback.\n\n3. What is the purpose of the `patch` method?\n- The `patch` method is used to perform any operations on a resource that require a dependency on its asset data or any other asset data. It takes an `Asset` object and an `AssetRegistry` object as parameters."
}