{
  "fileName": "TBNObjectSpace.js",
  "filePath": "src/scene/shader-lib/chunks/lit/frag/TBNObjectSpace.js",
  "url": "https://github.com/playcanvas/engine/src/scene/shader-lib/chunks/lit/frag/TBNObjectSpace.js",
  "summary": "The code provided is a GLSL shader function that calculates the tangent, binormal, and normal vectors of a given surface. These vectors are commonly used in 3D graphics for various purposes such as normal mapping, bump mapping, and lighting calculations.\n\nThe function takes in three parameters: `tangent`, `binormal`, and `normal`, which are all 3D vectors. The `normal` vector is the surface normal at a given point, while the `tangent` and `binormal` vectors are calculated based on the `normal` vector and another vector `vObjectSpaceUpW`.\n\nThe `T` vector is calculated by taking the cross product of the `normal` vector and `vObjectSpaceUpW`. The `B` vector is then calculated by taking the cross product of the `normal` vector and `T`. If the dot product of `B` with itself is zero, it means that `vObjectSpaceUpW` is parallel to the `normal` vector. In this case, the function calculates a new `B` and `T` vector based on the major component of the `normal` vector.\n\nFinally, the function creates a matrix `dTBN` using the `T`, `B`, and `normal` vectors. This matrix is used to transform vectors from tangent space to object space or vice versa.\n\nThis function is likely used in the PlayCanvas engine to calculate the tangent, binormal, and normal vectors for various surfaces in 3D scenes. These vectors can then be used for lighting calculations, normal mapping, and other visual effects. Here is an example of how this function might be used in a shader:\n\n```\nattribute vec3 aPosition;\nattribute vec3 aNormal;\nattribute vec2 aTexCoord;\n\nvarying vec2 vTexCoord;\nvarying vec3 vTangent;\nvarying vec3 vBinormal;\nvarying vec3 vNormal;\n\nuniform mat4 uModelMatrix;\nuniform mat4 uViewMatrix;\nuniform mat4 uProjectionMatrix;\n\nvoid main() {\n    // Transform position and normal to world space\n    vec4 worldPosition = uModelMatrix * vec4(aPosition, 1.0);\n    vec3 worldNormal = normalize(mat3(uModelMatrix) * aNormal);\n\n    // Calculate tangent, binormal, and normal vectors\n    vec3 tangent;\n    vec3 binormal;\n    getTBN(tangent, binormal, worldNormal);\n\n    // Transform tangent and binormal to world space\n    tangent = normalize(mat3(uModelMatrix) * tangent);\n    binormal = normalize(mat3(uModelMatrix) * binormal);\n\n    // Pass variables to fragment shader\n    vTexCoord = aTexCoord;\n    vTangent = tangent;\n    vBinormal = binormal;\n    vNormal = worldNormal;\n\n    // Transform position to clip space\n    gl_Position = uProjectionMatrix * uViewMatrix * worldPosition;\n}\n```",
  "questions": "1. What is the purpose of this code and where is it used in the PlayCanvas engine?\n- This code defines a function called `getTBN` which calculates the tangent, binormal, and normal vectors for a given surface. It is likely used in the rendering pipeline of the PlayCanvas engine to generate the necessary vectors for lighting and shading calculations.\n\n2. What are the input parameters for the `getTBN` function?\n- The `getTBN` function takes in three vec3 parameters: `tangent`, `binormal`, and `normal`. These represent the tangent, binormal, and normal vectors of the surface being rendered.\n\n3. What is the purpose of the conditional statement in the middle of the function?\n- The conditional statement checks if the `B` vector is zero, which can happen if the `vObjectSpaceUpW` vector is parallel to the surface normal. If this is the case, the function calculates a new `B` vector based on the component of the normal vector with the largest magnitude, and recalculates the `T` vector accordingly. This ensures that the `T`, `B`, and `N` vectors are always orthogonal and correctly represent the surface geometry."
}