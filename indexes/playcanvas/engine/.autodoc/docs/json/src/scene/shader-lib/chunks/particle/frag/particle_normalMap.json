{
  "fileName": "particle_normalMap.js",
  "filePath": "src/scene/shader-lib/chunks/particle/frag/particle_normalMap.js",
  "url": "https://github.com/playcanvas/engine/src/scene/shader-lib/chunks/particle/frag/particle_normalMap.js",
  "summary": "This code is a GLSL shader code that is used to calculate the normal vector of a particle in a particle system. The normal vector is an important property of a surface that is used in lighting calculations to determine how light interacts with the surface. \n\nThe code takes in a normal map texture and a texture coordinate (texCoordsAlphaLife) as input. The texture2D function is used to sample the normal map texture at the given texture coordinate. The resulting color value is then converted to a 3D vector (xyz) and normalized to ensure that its length is 1.0. \n\nNext, the normalized vector is scaled by 2.0 and then subtracted by 1.0. This operation maps the range of the vector from [0, 1] to [-1, 1]. This is a common technique used to convert texture data to a range that can be used in calculations. \n\nFinally, the resulting vector is transformed by a ParticleMat matrix to convert it from local space to world space. The resulting vector is the normal vector of the particle in world space. \n\nThis code is likely used in the larger PlayCanvas engine project to render particle systems with realistic lighting. The normal vector calculated by this code can be used in lighting calculations to determine how light interacts with the particle surface. \n\nExample usage of this code in a particle system shader:\n\n```\n// Vertex shader\nattribute vec3 vertex_position;\nattribute vec2 vertex_texCoordAlphaLife;\n\nuniform mat4 matrix_model;\nuniform mat4 matrix_viewProjection;\n\nvarying vec2 texCoordsAlphaLife;\n\nvoid main() {\n    // Transform vertex position to world space\n    vec4 worldPos = matrix_model * vec4(vertex_position, 1.0);\n    gl_Position = matrix_viewProjection * worldPos;\n    \n    // Pass texture coordinate to fragment shader\n    texCoordsAlphaLife = vertex_texCoordAlphaLife;\n}\n\n// Fragment shader\nuniform sampler2D normalMap;\nuniform mat4 ParticleMat;\n\nvarying vec2 texCoordsAlphaLife;\n\nvoid main() {\n    // Calculate normal vector of particle\n    vec3 normalMap = normalize(texture2D(normalMap, vec2(texCoordsAlphaLife.x, 1.0 - texCoordsAlphaLife.y)).xyz * 2.0 - 1.0);\n    vec3 normal = ParticleMat * normalMap;\n    \n    // Use normal vector in lighting calculations\n    // ...\n}\n```",
  "questions": "1. What is the purpose of the `normalize` function in the first line of code?\n    - The `normalize` function is used to ensure that the resulting vector has a length of 1, which is important for calculating accurate lighting and shading effects.\n\n2. What is the `ParticleMat` variable and how is it used in the second line of code?\n    - `ParticleMat` is likely a matrix used to transform the normal map vector into world space. It is multiplied by the normalized normal map vector to obtain the final normal vector.\n\n3. What is the significance of the `/* glsl */` comment at the beginning of the code?\n    - This comment indicates that the code is written in GLSL (OpenGL Shading Language), which is a specialized language used for writing shaders that run on the GPU. The comment is used by tools and editors to provide syntax highlighting and other features specific to GLSL."
}